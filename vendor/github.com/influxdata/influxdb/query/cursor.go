package query

import (
	"fmt"
	"time"

	"github.com/influxdata/influxql"
)

// Series represents the metadata about a series.
type Series struct {
	// Name is the measurement name.
	Name string

	// Tags for the series.
	Tags Tags

	// This is an internal id used to easily compare if a series is the
	// same as another series. Whenever the internal cursor changes
	// to a new series, this id gets incremented. It is not exposed to
	// the user so we can implement this in whatever way we want.
	// If a series is not generated by a cursor, this id is zero and
	// it will instead attempt to compare the name and tags.
	id uint64
}

// SameSeries checks if this is the same series as another one.
// It does not necessarily check for equality so this is different from
// checking to see if the name and tags are the same. It checks whether
// the two are part of the same series in the response.
func (s Series) SameSeries(other Series) bool {
	if s.id != 0 && other.id != 0 {
		return s.id == other.id
	}
	return s.Name == other.Name && s.Tags.ID() == other.Tags.ID()
}

// Equal checks to see if the Series are identical.
func (s Series) Equal(other Series) bool {
	if s.id != 0 && other.id != 0 {
		// If the ids are the same, then we can short-circuit and assume they
		// are the same. If they are not the same, do the long check since
		// they may still be identical, but not necessarily generated from
		// the same cursor.
		if s.id == other.id {
			return true
		}
	}
	return s.Name == other.Name && s.Tags.ID() == other.Tags.ID()
}

// Row represents a single row returned by the query engine.
type Row struct {
	// Time returns the time for this row. If the cursor was created to
	// return time as one of the values, the time will also be included as
	// a time.Time in the appropriate column within Values.
	// This ensures that time is always present in the Row structure
	// even if it hasn't been requested in the output.
	Time int64

	// Series contains the series metadata for this row.
	Series Series

	// Values contains the values within the current row.
	Values []interface{}
}

type Cursor interface {
	// Scan will retrieve the next row and assign the result to
	// the passed in Row. If the Row has not been initialized, the Cursor
	// will initialize the Row.
	// To increase speed and memory usage, the same Row can be used and
	// the previous values will be overwritten while using the same memory.
	Scan(row *Row) bool

	// Err returns any errors that were encountered from scanning the rows.
	Err() error

	// Columns returns the column names and types.
	Columns() []influxql.VarRef

	// Close closes the underlying resources that the cursor is using.
	Close() error
}

type cursor struct {
	buf       []Point
	itrs      []Iterator
	ascending bool

	series Series
	err    error

	columns  []influxql.VarRef
	omitTime bool
	loc      *time.Location
}

func newCursor(itrs []Iterator, columns []influxql.VarRef, ascending bool) *cursor {
	return &cursor{
		buf:       make([]Point, len(itrs)),
		itrs:      itrs,
		ascending: ascending,
		columns:   columns,
		loc:       time.UTC,
	}
}

func (cur *cursor) Scan(row *Row) bool {
	// Immediately end the scan if there are no iterators.
	if len(cur.itrs) == 0 {
		return false
	}

	t, name, tags, err := cur.loadBuf()
	if err != nil {
		cur.err = err
		return false
	}

	if t == ZeroTime {
		return false
	}
	row.Time = t

	// Check to see if the name or tags have changed.
	// If they have, copy them over and update the series id.
	if name != cur.series.Name || tags.ID() != cur.series.Tags.ID() {
		cur.series.id++
		cur.series.Name = name
		cur.series.Tags = tags
	}
	row.Series = cur.series

	// If the row values is not large enough, allocate a slice.
	if len(row.Values) < len(cur.columns) {
		row.Values = make([]interface{}, len(cur.columns))
	}
	if !cur.omitTime {
		row.Values[0] = time.Unix(0, t).In(cur.loc)
		cur.readInto(t, name, tags, row.Values[1:])
	} else {
		cur.readInto(t, name, tags, row.Values)
	}
	return true
}

// loadBuf reads in points into empty buffer slots.
// Returns the next time/name/tags to emit for.
func (cur *cursor) loadBuf() (t int64, name string, tags Tags, err error) {
	t = ZeroTime

	for i := range cur.itrs {
		// Load buffer, if empty.
		if cur.buf[i] == nil {
			cur.buf[i], err = cur.readIterator(cur.itrs[i])
			if err != nil {
				break
			}
		}

		// Skip if buffer is empty.
		p := cur.buf[i]
		if p == nil {
			continue
		}
		itrTime, itrName, itrTags := p.time(), p.name(), p.tags()
		// Initialize range values if not set.
		if t == ZeroTime {
			t, name, tags = itrTime, itrName, itrTags
			continue
		}

		// Update range values if lower and emitter is in time ascending order.
		if cur.ascending {
			if (itrName < name) || (itrName == name && itrTags.ID() < tags.ID()) || (itrName == name && itrTags.ID() == tags.ID() && itrTime < t) {
				t, name, tags = itrTime, itrName, itrTags
			}
			continue
		}

		// Update range values if higher and emitter is in time descending order.
		if (itrName > name) || (itrName == name && itrTags.ID() > tags.ID()) || (itrName == name && itrTags.ID() == tags.ID() && itrTime > t) {
			t, name, tags = itrTime, itrName, itrTags
		}
	}
	return
}

func (cur *cursor) readInto(t int64, name string, tags Tags, values []interface{}) {
	for i, p := range cur.buf {
		// Skip if buffer is empty.
		if p == nil {
			values[i] = nil
			continue
		}

		// Skip point if it doesn't match time/name/tags.
		pTags := p.tags()
		if p.time() != t || p.name() != name || !pTags.Equals(&tags) {
			values[i] = nil
			continue
		}

		// Read point value.
		values[i] = p.value()

		// Clear buffer.
		cur.buf[i] = nil
	}
}

// readIterator reads the next point from itr.
func (cur *cursor) readIterator(itr Iterator) (Point, error) {
	if itr == nil {
		return nil, nil
	}

	switch itr := itr.(type) {
	case FloatIterator:
		if p, err := itr.Next(); err != nil {
			return nil, err
		} else if p != nil {
			return p, nil
		}
	case IntegerIterator:
		if p, err := itr.Next(); err != nil {
			return nil, err
		} else if p != nil {
			return p, nil
		}
	case UnsignedIterator:
		if p, err := itr.Next(); err != nil {
			return nil, err
		} else if p != nil {
			return p, nil
		}
	case StringIterator:
		if p, err := itr.Next(); err != nil {
			return nil, err
		} else if p != nil {
			return p, nil
		}
	case BooleanIterator:
		if p, err := itr.Next(); err != nil {
			return nil, err
		} else if p != nil {
			return p, nil
		}
	default:
		panic(fmt.Sprintf("unsupported iterator: %T", itr))
	}
	return nil, nil
}

func (cur *cursor) Err() error {
	return cur.err
}

func (cur *cursor) Columns() []influxql.VarRef {
	return cur.columns
}

func (cur *cursor) Close() error {
	return Iterators(cur.itrs).Close()
}

// RowCursor returns a Cursor that iterates over Rows.
func RowCursor(rows []Row, columns []influxql.VarRef) Cursor {
	return &rowCursor{
		rows:    rows,
		columns: columns,
	}
}

type rowCursor struct {
	rows    []Row
	columns []influxql.VarRef

	series Series
}

func (cur *rowCursor) Scan(row *Row) bool {
	if len(cur.rows) == 0 {
		return false
	}

	*row = cur.rows[0]
	if row.Series.Name != cur.series.Name || !row.Series.Tags.Equals(&cur.series.Tags) {
		cur.series.Name = row.Series.Name
		cur.series.Tags = row.Series.Tags
		cur.series.id++
	}
	cur.rows = cur.rows[1:]
	return true
}

func (cur *rowCursor) Err() error {
	return nil
}

func (cur *rowCursor) Columns() []influxql.VarRef {
	return cur.columns
}

func (cur *rowCursor) Close() error {
	return nil
}

// DrainCursor will read and discard all values from a Cursor and return the error
// if one happens.
func DrainCursor(cur Cursor) error {
	var row Row
	for cur.Scan(&row) {
		// Do nothing with the result.
	}
	return cur.Err()
}
